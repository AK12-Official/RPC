> 会随着版本的不断迭代而更新 以便和实际编码保持一致

## Stage 1 服务端启动

1. 创建服务实现：实例化 UserServiceImpl
2. 注册服务：通过 ServiceProvider.provideServiceInterface() 将服务注册到 Map（接口名 → 实现对象）
3. 启动 Netty 服务器：
    - 创建 bossGroup 和 workGroup
    - 配置 NettyServerInitializer（编解码器 + NettyRPCServerHandler）
    - 绑定端口 19999，开始监听

## Stage 2 客户端启动并调用

```java
public static void main(String[] args) {
    //创建ClientProxy对象
    ClientProxy clientProxy = new ClientProxy("127.0.0.1", 19999);
    //通过ClientProxy对象获取代理对象
    UserService proxy = clientProxy.getProxy(UserService.class);
    //调用代理对象的方法
    User user = proxy.getUserByUserId(1);
    System.out.println("User Got From Server: " + user);

    User u=User.builder().id(100).userName("lzx").sex(true).build();
    Integer id =proxy.insertUserId(u);
    System.out.println("The Id Inserted to Server: " + id);
}
```

## DataFlow

步骤 1：创建代理对象
- ClientProxy 使用 JDK 动态代理创建 UserService 的代理对象
- 代理对象的方法调用会进入 ClientProxy.invoke()

步骤 2：构建 RpcRequest（客户端）
```java
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    //构建Request
    RpcRequest rpcRequest = RpcRequest.builder()
            .interfaceName(method.getDeclaringClass().getName())
            .methodName(method.getName())
            .params(args).paramsType(method.getParameterTypes())
            .build();
```
- 从方法反射信息构建 RpcRequest，包含：
    - interfaceName: 接口全限定名（如 common.service.UserService）
    - methodName: 方法名（如 getUserByUserId）
    - params: 参数数组（如 [1]）
    - paramsType: 参数类型数组（如 [Integer.class]）


步骤 3：发送请求（客户端）
- 建立 Netty 连接（127.0.0.1:19999）
- 通过 Channel 发送 RpcRequest
- 数据经过客户端 Pipeline：
    1. LengthFieldPrepender：添加长度字段（4 字节）
    2. ObjectEncoder：Java 序列化
    3. 通过 TCP 发送到服务端

步骤 4：服务端接收并解码
- 服务端 Pipeline 处理：
    1. LengthFieldBasedFrameDecoder：按长度字段拆包
    2. ObjectDecoder：反序列化为 RpcRequest
    3. NettyRPCServerHandler：处理请求

步骤 5：服务端处理请求
```java
protected void channelRead0(ChannelHandlerContext ctx, RpcRequest request) throws Exception {
    //接收request，读取并调用服务
    RpcResponse response = getResponse(request);
    ctx.writeAndFlush(response);
    ctx.close();
}
```
- 从 ServiceProvider 获取服务实现对象
- 通过反射调用方法
- 构建 RpcResponse（成功或失败）

步骤 6：服务端返回响应
- 通过 Channel 发送 RpcResponse
- 数据经过服务端 Pipeline：
    1. LengthFieldPrepender：添加长度字段
    2. ObjectEncoder：Java 序列化
    3. 通过 TCP 返回客户端

步骤 7：客户端接收响应
```java
protected void channelRead0(ChannelHandlerContext ctx, RpcResponse response) throws Exception {
    // 接收到response, 给channel设计别名，让sendRequest里读取response
    AttributeKey<RpcResponse> key = AttributeKey.valueOf("RPCResponse");
    ctx.channel().attr(key).set(response);
    ctx.channel().close();
}
```
- 客户端 Pipeline 处理：
    1. LengthFieldBasedFrameDecoder：拆包
    2. ObjectDecoder：反序列化为 RpcResponse
    3. NettyClientHandler：将响应存入 Channel 的 Attribute
    4. 关闭 Channel

步骤 8：客户端获取结果
- NettyRpcClient.sendRequest() 从 Channel 的 Attribute 读取 RpcResponse
- ClientProxy.invoke() 返回 response.getData()
- 代理对象返回结果给调用方