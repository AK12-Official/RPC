> 会随着版本的不断迭代而更新 以便和实际编码保持一致

## Stage 1 服务端启动

1. 创建服务实现：实例化 `UserServiceImpl`
2. 创建 `ServiceProvider(host, port)`
    - 内部初始化本地映射表 `Map<String,Object>`（接口全限定名 → 实现对象）
    - 内部初始化注册中心客户端：`ZKServiceRegister`（连接 Zookeeper，namespace = `MyRPC`）
3. 注册服务：`serviceProvider.provideServiceInterface(userService)`
    - 将实现类实现的每个接口名 `clazz.getName()` 写入本地 `Map`
    - 同时向 Zookeeper 注册地址：
        - 创建持久节点：`/MyRPC/<serviceName>`（若不存在）
        - 创建临时节点：`/MyRPC/<serviceName>/<host:port>`（服务下线会自动删除）
4. 启动 Netty 服务器：`NettyRPCServer.start(port)`
    - 创建 `bossGroup` 和 `workGroup`
    - 配置 `NettyServerInitializer(serviceProvider)`（自定义编解码器 + `NettyRPCServerHandler`）
    - bind 端口（示例为 19999）开始监听

## Stage 2 客户端启动并调用

```java
public static void main(String[] args) {
    //创建ClientProxy对象
    ClientProxy clientProxy=new ClientProxy();  //不再需要写死 ip & port（从 Zookeeper 服务发现）
    //通过ClientProxy对象获取代理对象
    UserService proxy = clientProxy.getProxy(UserService.class);
    //调用代理对象的方法
    User user = proxy.getUserByUserId(1);
    System.out.println("User Got From Server: " + user);

    User u=User.builder().id(100).userName("lzx").sex(true).build();
    Integer id =proxy.insertUserId(u);
    System.out.println("The Id Inserted to Server: " + id);
}
```

## DataFlow

步骤 1：创建代理对象
- `ClientProxy` 使用 JDK 动态代理创建 `UserService` 的代理对象
- 每次调用代理方法都会进入 `ClientProxy.invoke()`

步骤 2：构建 RpcRequest（客户端）
```java
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    //构建Request
    RpcRequest rpcRequest = RpcRequest.builder()
            .interfaceName(method.getDeclaringClass().getName())
            .methodName(method.getName())
            .params(args).paramsType(method.getParameterTypes())
            .build();
}
```
- 从方法反射信息构建 RpcRequest，包含：
    - interfaceName: 接口全限定名（如 common.service.UserService）
    - methodName: 方法名（如 getUserByUserId）
    - params: 参数数组（如 [1]）
    - paramsType: 参数类型数组（如 [Integer.class]）


步骤 3：服务发现（客户端）
- `NettyRpcClient` 内部持有 `ZKServiceCenter`
- `sendRequest(request)` 时根据 `request.getInterfaceName()` 到 Zookeeper 查询：
    - 读取 `/MyRPC/<serviceName>` 下的子节点列表
    - 当前实现默认取第一个地址（后续可扩展负载均衡）

步骤 3：发送请求（客户端）
（与旧版本不同：不再使用 `LengthFieldPrepender/ObjectEncoder`，而是自定义协议头 + JSON 序列化）

- 建立 Netty 连接（connect 到步骤 3 发现的 host:port）
- 通过 `channel.writeAndFlush(rpcRequest)` 发送请求
- 客户端 pipeline（`NettyClientInitializer`）：
    1. `Decoder`（入站：ByteBuf → Java 对象）
    2. `Encoder(JsonSerializer)`（出站：Java 对象 → ByteBuf）
    3. `NettyClientHandler`（入站：拿到 `RpcResponse` 写入 channel attribute 并 close）

客户端自定义协议（Encoder 写入的顺序）：

```
[2B messageType][2B serializerType][4B length][N bytes body]
messageType: REQUEST=0 / RESPONSE=1
serializerType: ObjectSerializer=0 / JsonSerializer=1
```

其中 `body` 是 `JsonSerializer.serialize(obj)` 的结果。

步骤 4：服务端接收并解码
- 服务端 pipeline（`NettyServerInitializer`）：
    1. `Encoder(JsonSerializer)`（出站）
    2. `Decoder`（入站）
    3. `NettyRPCServerHandler(serviceProvider)`（入站业务处理）
- 入站请求到达后，`Decoder` 按协议头读取：
    - `messageType=0` → 反序列化为 `RpcRequest`
    - 通过 `serializerType` 选择序列化器（当前 pipeline 使用的是 `JsonSerializer`）
- `JsonSerializer` 在反序列化 `RpcRequest` 时，会根据 `paramsType` 对 `params` 做类型修正（例如把 `JSONObject` 转回真实参数类型），确保服务端反射调用参数匹配。

步骤 5：服务端处理请求
```java
protected void channelRead0(ChannelHandlerContext ctx, RpcRequest request) throws Exception {
    //接收request，读取并调用服务
    RpcResponse response = getResponse(request);
    ctx.writeAndFlush(response);
    ctx.close();
}
```
- 从 ServiceProvider 获取服务实现对象
- 通过反射调用方法
- 构建 RpcResponse（成功或失败）

步骤 6：服务端返回响应
- `ctx.writeAndFlush(response)` 触发出站
- `Encoder(JsonSerializer)` 将 `RpcResponse` 写成 ByteBuf（同一套协议头）
- 服务端当前实现会在写回响应后 `ctx.close()`（一次请求处理完就断开连接）

步骤 7：客户端接收响应
```java
protected void channelRead0(ChannelHandlerContext ctx, RpcResponse response) throws Exception {
    // 接收到response, 给channel设计别名，让sendRequest里读取response
    AttributeKey<RpcResponse> key = AttributeKey.valueOf("RPCResponse");
    ctx.channel().attr(key).set(response);
    ctx.channel().close();
}
```
- 客户端入站 ByteBuf 先经过 `Decoder`，反序列化得到 `RpcResponse`
- `JsonSerializer` 在反序列化 `RpcResponse` 时会尝试把 `data` 从 `JSONObject` 转回真实类型（依赖 `RpcResponse.dataType`）
- `NettyClientHandler` 将响应存入 Channel 的 AttributeKey：`RPCResponse`，然后关闭连接

步骤 8：客户端获取结果
- `NettyRpcClient.sendRequest()` 阻塞等待 `channel.closeFuture().sync()`
- 连接关闭后，从 `channel.attr(AttributeKey.valueOf("RPCResponse"))` 取回 `RpcResponse`
- `ClientProxy.invoke()` 返回 `response.getData()` 作为本次远程调用结果

## 备注（当前实现的关键约束）

1. 当前是“一次请求一次连接”：client/server handler 都会在处理完响应/请求后关闭 channel。
2. 当前 `Decoder` 没有做半包/粘包的完整处理（读取前未检查 `readableBytes`），在复杂网络环境可能需要补充帧解码/边界处理。